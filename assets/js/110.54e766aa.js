(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{526:function(v,_,o){"use strict";o.r(_);var e=o(12),t=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"docker-数据管理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#docker-数据管理"}},[v._v("#")]),v._v(" Docker 数据管理")]),v._v(" "),_("p",[v._v("前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 "),_("strong",[v._v("容器存储层")]),v._v("。")]),v._v(" "),_("p",[v._v("容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。")]),v._v(" "),_("p",[v._v("按照 "),_("code",[v._v("Docker")]),v._v(" 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 "),_("strong",[v._v("数据卷（Volume）")]),v._v("、或者 "),_("strong",[v._v("绑定宿主目录")]),v._v("，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。")]),v._v(" "),_("p",[v._v("数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。")]),v._v(" "),_("p",[_("code",[v._v("Docker")]),v._v(" 主要提供了两种方式对数据进行持久化存储：")]),v._v(" "),_("ul",[_("li",[v._v("数据卷（"),_("code",[v._v("Volume")]),v._v("），由 "),_("code",[v._v("Docker")]),v._v(" 管理，("),_("code",[v._v("/var/lib/docker/volumes/name")]),v._v(")，持久化数据的最好方式；")]),v._v(" "),_("li",[v._v("绑定宿主目录 ("),_("code",[v._v("Bind mounts")]),v._v(")，由用户指定数据存储在宿主机的什么位置；")])])])}),[],!1,null,null,null);_.default=t.exports}}]);