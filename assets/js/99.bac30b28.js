(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{515:function(e,t,r){"use strict";r.r(t);var o=r(12),n=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"docker-容器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#docker-容器"}},[e._v("#")]),e._v(" Docker 容器")]),e._v(" "),t("p",[e._v("镜像（ "),t("code",[e._v("Image")]),e._v(" ）和容器（ "),t("code",[e._v("Container")]),e._v(" ）的关系，就像是面向对象程序设计中的 "),t("code",[e._v("类")]),e._v(" 和 "),t("code",[e._v("实例")]),e._v(" 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。")]),e._v(" "),t("p",[e._v("容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Linux_namespaces",target:"_blank",rel:"noopener noreferrer"}},[e._v("命名空间"),t("OutboundLink")],1),e._v("。因此容器可以拥有自己的 "),t("code",[e._v("root")]),e._v(" 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。")])])}),[],!1,null,null,null);t.default=n.exports}}]);